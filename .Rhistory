#' candidate buffer and arranges them in descending order.
#' @param cands \code{data.frame} of associations between points and nest
#' candidates returned by \code{\link{get_candidates}}
#' @return Returns \code{tibble} counting number of points within each
#' candidate buffer.
candidate_summary <- function(cands){
cands <- cands %>%
group_by(group_id) %>%
tally() %>%
arrange(desc(n))
# Return result
return(cands)
}
# Summarize candidates
cands_count <- candidate_summary(cands)
# Join group ID back to the original data
dat <- left_join(dat, cands, by = "loc_id")
# Save computation time: discard group IDs that appear on < 2 days
keepers <- dat %>%
group_by(group_id, reldate) %>%
tally() %>%
filter(n >= 2) %>%
pull(group_id) %>%
unique()
keepers
# Subset data for group_ids of interest
sub <- dat %>%
filter(group_id %in% keepers)
# Sequence of all the possible days in the season
all_days <- 0:max(sub$reldate)
all_days
# Initialize output
out <- data.frame(group_id = sort(unique(sub$group_id)))
out
# Number of fixes per day
daily_fixes <- sub %>%
group_by(reldate) %>%
summarize(n_fixes = n()) %>%
select(reldate, n_fixes) %>%
arrange(reldate)
daily_fixes
sub
# Day of first and last visit
first_vis <- sub %>%
group_by(group_id) %>%
summarize(first_date=as_date(min(date)), first_reldate=min(reldate))
first_vis
last_vis <- sub %>%
group_by(group_id) %>%
summarize(last_date=as_date(max(date)), last_reldate=max(reldate))
last_vis
# Join to output
out <- out %>%
left_join(first_vis, by = "group_id") %>%
left_join(last_vis, by = "group_id")
out
# Total number of visits
tot_visits <- sub %>%
group_by(group_id) %>%
summarize(tot_vis = n())
tot_visits
# Number of days visited
days_visited <- sub %>%
group_by(group_id) %>%
summarize(days_vis = n_distinct(reldate))
days_visited
sub
sub %>% filter(group_id==154)
sub %>% filter(group_id==154) %>% unique(date(date))
sub %>% filter(group_id==154) %>% unique(reldate)
sub %>% filter(group_id==154) %>% pull(reldate) %>% unique
lk_nests <- readRDS("~/Documents/PhD/Research/Wood Stork/WOST_repo/nesting/output/lk_nests.rds")
nest_info <- lk_nests
nest_cycle = 35
# Create unique attempt identifier
attempts <- nest_info$nests %>%
mutate(attempt_id = paste0(burst, "_", loc_id))
attempts
# Matrix 1: number of fixes per day
mat_fix <- matrix(NA, nrow = nrow(attempts), ncol = nest_cycle)
# Matrix 2: number of visits per day
mat_vis <- matrix(NA, nrow = nrow(attempts), ncol = nest_cycle)
# Set up rownames
rownames(mat_fix) <- rownames(mat_vis) <- 1:nrow(mat_fix)
i=2
# Select current attempt
att <- attempts[i,]
att
# Data on nest revisits
visits <- nest_info$visits %>%
filter(burst == att$burst)
visits
att$attempt_start
# Cut between attempt start and end of nesting cycle
visits <- visits %>%
filter(between(date,
att$attempt_start,
att$attempt_start + nest_cycle))
visits
# Count daily fixes within attempt
fix <- visits %>%
group_by(date = as_date(date)) %>%
tally()
# Count daily visits within attempt
vis <- visits %>%
filter(loc_id == att$loc_id) %>%
group_by(date = as_date(date)) %>%
tally()
vis
as_date(2017-06-15) + 35
# Initialize visit history
history <- data.frame(
date = as_date(att$attempt_start:(att$attempt_start + nest_cycle - 1)))
history
# Join n of fixes and visits
history <- left_join(history, fix, by = "date")
history <- left_join(history, vis, by = "date")
history
attempts
i=40
# Select current attempt
att <- attempts[i,]
att
# Data on nest revisits
visits <- nest_info$visits %>%
filter(burst == att$burst)
# Cut between attempt start and end of nesting cycle
visits <- visits %>%
filter(between(date,
att$attempt_start,
att$attempt_start + nest_cycle))
# Count daily fixes within attempt
fix <- visits %>%
group_by(date = as_date(date)) %>%
tally()
# Count daily visits within attempt
vis <- visits %>%
filter(loc_id == att$loc_id) %>%
group_by(date = as_date(date)) %>%
tally()
# Initialize visit history
history <- data.frame(
date = as_date(att$attempt_start:(att$attempt_start + nest_cycle - 1)))
# Join n of fixes and visits
history <- left_join(history, fix, by = "date")
history <- left_join(history, vis, by = "date")
history
#Join to output
out <- out %>%
left_join(tot_visits, by = "group_id") %>%
left_join(days_visited, by = "group_id")
# Percent days visited between first and last
out <- out %>%
mutate(perc_days_vis =
round(days_vis*100/(last_reldate - first_reldate + 1), 2))
# Count daily visits
daily_visits <- sub %>%
group_by(group_id, reldate) %>%
summarize(n_visits = n())
# Create data.frame of the range of days a group_id appears
group_id_range <- data.frame(group_id = rep(out$group_id, each=length(all_days)),
reldate = rep(0:max(sub$reldate), length(out$group_id))
) %>%
left_join(first_vis, by = "group_id") %>%
left_join(last_vis, by = "group_id") %>%
filter(between(reldate, first_reldate, last_reldate)) %>%
select(group_id, reldate)
# Combine with daily_visits
daily_visits <- group_id_range %>%
left_join(daily_visits, by = c("group_id", "reldate")) %>%
mutate(n_visits = case_when(
is.na(n_visits) ~ 0L,
TRUE ~ n_visits
)) %>%
left_join(daily_fixes, by = "reldate") %>%
mutate(n_fixes = case_when(
is.na(n_fixes) ~ 0L,
TRUE ~ n_fixes
))
# Find day with most visits
top_day_visits <- daily_visits %>%
group_by(group_id) %>%
filter(n_visits == max(n_visits)) %>%
mutate(percent_vis = round(n_visits*100/n_fixes, 2)) %>%
summarize(perc_top_vis = max(percent_vis))
# Join with output
out <- out %>%
left_join(top_day_visits, by = "group_id")
out
daily_visits
daily_visits %>%
filter(n_visits > 0 | n_fixes >= min_d_fix) %>%
mutate(visited = n_visits > 0)
# For calculating consecutive visits, drop any days without the
# minimum number of required fixes where a visit is not recorded
filtered_dv <- daily_visits %>%
filter(n_visits > 0 | n_fixes >= min_d_fix) %>%
mutate(visited = n_visits > 0)
# For each group_id, calculate the maximum number of consecutive days with a visit
# Split into list by group_id
filtered_list <- split(filtered_dv, filtered_dv$group_id)
filtered_list
# lapply() custom function 'visit_rle()'
filtered_rle <- lapply(filtered_list, visit_rle)
#'
#' \code{visit_rle} calculates the run-length encoding of visits based on
#' the daily history of revisitation of a candidate nest.
#'
#' @details Used with \code{lapply} inside function \code{revisit_stats}.
#' Performs run-length encoding of nest visits and formats as
#' \code{data.frame} for later use.
#' @param x \code{data.frame} of daily revisitation history of a
#' candidate nest
#' @return Returns \code{data.frame} of run-length encoding of nest visits.
visit_rle <- function(x){
# Calculate rle
rl <- rle(x[["visited"]])
# Convert to data.frame
rl_df <- data.frame(lengths=rl$lengths, values=rl$values,
end = cumsum(rl$lengths)) %>%
mutate(start = end - lengths + 1) %>%
select(lengths, values, start, end)
return(rl_df)
}
filtered_list
daily_fixes
daily_fixes %>% as.data.frame()
gps_data
# Check format of input data
check_input(gps_data)
burst_id
burst_id <- "16683-2017"
cat(paste0("Burst ", i, " of ", length(bursts), "\n"))
dat <- gps_data %>%
filter(burst==burst_id)
# Order by date and assign location id
dat <- dat %>%
arrange(date) %>%
mutate(loc_id = 1:nrow(.)) %>%
select(loc_id, everything())
# Handle dates
dates_out <- date_handler(dat, sea_start, sea_end)
# dates_out is a list; pull the data from it
dat <- dates_out$dat
dmat <- dist_mat(dat)
cands <- get_candidates(dm = dmat, buffer = buffer, min_pts = min_pts)
# Summarize candidates
cands_count <- candidate_summary(cands)
# Join group ID back to the original data
dat <- left_join(dat, cands, by = "loc_id")
# Save computation time: discard group IDs that appear on < 2 days
keepers <- dat %>%
group_by(group_id, reldate) %>%
tally() %>%
filter(n >= 2) %>%
pull(group_id) %>%
unique()
# Subset data for group_ids of interest
sub <- dat %>%
filter(group_id %in% keepers)
# Sequence of all the possible days in the season
all_days <- 0:max(sub$reldate)
# Initialize output
out <- data.frame(group_id = sort(unique(sub$group_id)))
# Number of fixes per day
daily_fixes <- sub %>%
group_by(reldate) %>%
summarize(n_fixes = n()) %>%
select(reldate, n_fixes) %>%
arrange(reldate)
daily_fixes
# Day of first and last visit
first_vis <- sub %>%
group_by(group_id) %>%
summarize(first_date=as_date(min(date)), first_reldate=min(reldate))
last_vis <- sub %>%
group_by(group_id) %>%
summarize(last_date=as_date(max(date)), last_reldate=max(reldate))
first_vis
# Join to output
out <- out %>%
left_join(first_vis, by = "group_id") %>%
left_join(last_vis, by = "group_id")
out
# Total number of visits
tot_visits <- sub %>%
group_by(group_id) %>%
summarize(tot_vis = n())
# Number of days visited
days_visited <- sub %>%
group_by(group_id) %>%
summarize(days_vis = n_distinct(reldate))
days_visited
#Join to output
out <- out %>%
left_join(tot_visits, by = "group_id") %>%
left_join(days_visited, by = "group_id")
out
# Percent days visited between first and last
out <- out %>%
mutate(perc_days_vis =
round(days_vis*100/(last_reldate - first_reldate + 1), 2))
# Count daily visits
daily_visits <- sub %>%
group_by(group_id, reldate) %>%
summarize(n_visits = n())
# Create data.frame of the range of days a group_id appears
group_id_range <- data.frame(group_id = rep(out$group_id, each=length(all_days)),
reldate = rep(0:max(sub$reldate), length(out$group_id))
) %>%
left_join(first_vis, by = "group_id") %>%
left_join(last_vis, by = "group_id") %>%
filter(between(reldate, first_reldate, last_reldate)) %>%
select(group_id, reldate)
# Combine with daily_visits
daily_visits <- group_id_range %>%
left_join(daily_visits, by = c("group_id", "reldate")) %>%
mutate(n_visits = case_when(
is.na(n_visits) ~ 0L,
TRUE ~ n_visits
)) %>%
left_join(daily_fixes, by = "reldate") %>%
mutate(n_fixes = case_when(
is.na(n_fixes) ~ 0L,
TRUE ~ n_fixes
))
# Find day with most visits
top_day_visits <- daily_visits %>%
group_by(group_id) %>%
filter(n_visits == max(n_visits)) %>%
mutate(percent_vis = round(n_visits*100/n_fixes, 2)) %>%
summarize(perc_top_vis = max(percent_vis))
# Join with output
out <- out %>%
left_join(top_day_visits, by = "group_id")
# For calculating consecutive visits, drop any days without the
# minimum number of required fixes where a visit is not recorded
filtered_dv <- daily_visits %>%
filter(n_visits > 0 | n_fixes >= min_d_fix) %>%
mutate(visited = n_visits > 0)
filtered_dv
daily_visits
View(sub)
# Number of fixes per day
daily_fixes <- sub %>%
group_by(reldate) %>%
summarize(n_fixes = n()) %>%
select(reldate, n_fixes) %>%
arrange(reldate)
daily_fixes
sub
dat
daily_fixes
# Number of fixes per day
daily_fixes <- dat %>%
group_by(reldate) %>%
summarize(n_fixes = n()) %>%
select(reldate, n_fixes) %>%
arrange(reldate)
daily_fixes
# Day of first and last visit
first_vis <- sub %>%
group_by(group_id) %>%
summarize(first_date=as_date(min(date)), first_reldate=min(reldate))
last_vis <- sub %>%
group_by(group_id) %>%
summarize(last_date=as_date(max(date)), last_reldate=max(reldate))
# Join to output
out <- out %>%
left_join(first_vis, by = "group_id") %>%
left_join(last_vis, by = "group_id")
# Total number of visits
tot_visits <- sub %>%
group_by(group_id) %>%
summarize(tot_vis = n())
# Number of days visited
days_visited <- sub %>%
group_by(group_id) %>%
summarize(days_vis = n_distinct(reldate))
#Join to output
out <- out %>%
left_join(tot_visits, by = "group_id") %>%
left_join(days_visited, by = "group_id")
# Percent days visited between first and last
out <- out %>%
mutate(perc_days_vis =
round(days_vis*100/(last_reldate - first_reldate + 1), 2))
days_visited
#Join to output
out <- out %>%
left_join(tot_visits, by = "group_id") %>%
left_join(days_visited, by = "group_id")
out
# Initialize output
out <- data.frame(group_id = sort(unique(sub$group_id)))
# Number of fixes per day
daily_fixes <- dat %>%
group_by(reldate) %>%
summarize(n_fixes = n()) %>%
select(reldate, n_fixes) %>%
arrange(reldate)
# Day of first and last visit
first_vis <- sub %>%
group_by(group_id) %>%
summarize(first_date=as_date(min(date)), first_reldate=min(reldate))
last_vis <- sub %>%
group_by(group_id) %>%
summarize(last_date=as_date(max(date)), last_reldate=max(reldate))
# Join to output
out <- out %>%
left_join(first_vis, by = "group_id") %>%
left_join(last_vis, by = "group_id")
out
# Total number of visits
tot_visits <- sub %>%
group_by(group_id) %>%
summarize(tot_vis = n())
tot_visits
# Number of days visited
days_visited <- sub %>%
group_by(group_id) %>%
summarize(days_vis = n_distinct(reldate))
days_visited
#Join to output
out <- out %>%
left_join(tot_visits, by = "group_id") %>%
left_join(days_visited, by = "group_id")
out
# Percent days visited between first and last
out <- out %>%
mutate(perc_days_vis =
round(days_vis*100/(last_reldate - first_reldate + 1), 2))
out
# Count daily visits
daily_visits <- sub %>%
group_by(group_id, reldate) %>%
summarize(n_visits = n())
daily_visits
# Create data.frame of the range of days a group_id appears
group_id_range <- data.frame(group_id = rep(out$group_id, each=length(all_days)),
reldate = rep(0:max(sub$reldate), length(out$group_id))
) %>%
left_join(first_vis, by = "group_id") %>%
left_join(last_vis, by = "group_id") %>%
filter(between(reldate, first_reldate, last_reldate)) %>%
select(group_id, reldate)
# Combine with daily_visits
daily_visits <- group_id_range %>%
left_join(daily_visits, by = c("group_id", "reldate")) %>%
mutate(n_visits = case_when(
is.na(n_visits) ~ 0L,
TRUE ~ n_visits
)) %>%
left_join(daily_fixes, by = "reldate") %>%
mutate(n_fixes = case_when(
is.na(n_fixes) ~ 0L,
TRUE ~ n_fixes
))
# Find day with most visits
top_day_visits <- daily_visits %>%
group_by(group_id) %>%
filter(n_visits == max(n_visits)) %>%
mutate(percent_vis = round(n_visits*100/n_fixes, 2)) %>%
summarize(perc_top_vis = max(percent_vis))
# Join with output
out <- out %>%
left_join(top_day_visits, by = "group_id")
# For calculating consecutive visits, drop any days without the
# minimum number of required fixes where a visit is not recorded
filtered_dv <- daily_visits %>%
filter(n_visits > 0 | n_fixes >= min_d_fix) %>%
mutate(visited = n_visits > 0)
# For each group_id, calculate the maximum number of consecutive days with a visit
# Split into list by group_id
filtered_list <- split(filtered_dv, filtered_dv$group_id)
# lapply() custom function 'visit_rle()'
filtered_rle <- lapply(filtered_list, visit_rle)
# lapply() custom function 'rle_to_consec()'
max_days_list <- lapply(filtered_rle, rle_to_consec)
#'
#' \code{rle_to_consec} calculates the longest sequence of consecutive days a
#' candidate nest was visited.
#'
#' @details Used with \code{lapply} inside function \code{revisit_stats}.
#' Computes longest series of consecutive days a candidate nest was visited.
#' Takes as input the output of \code{visit_rle}.
#' @param rl_df \code{data.frame} of run-length encoding of nest visits
#' @return Returns maximum number of consecutive days when the candidate
#' nest was visited.
rle_to_consec <- function(rl_df) {
rl_df <- rl_df  %>%
filter(values) %>%
filter(lengths == max(lengths))
return(max(rl_df$lengths))
}
# lapply() custom function 'rle_to_consec()'
max_days_list <- lapply(filtered_rle, rle_to_consec)
# Combine results in data.frame
consec_days <- data.frame(group_id = as.integer(names(max_days_list)),
consec_days = unlist(max_days_list))
# Join with output
out <- out %>%
left_join(consec_days, by = "group_id")
# Compute start and end dates of nesting attempt
start_end <- lapply(filtered_list, attempt_limits,
min_consec = min_consec,
nest_cycle = nest_cycle) %>%
bind_rows()
out
library(nestR)
library(nestR)
library(nestR)
