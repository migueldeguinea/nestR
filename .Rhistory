min_pts = 2
min_d_fix = 5
min_consec = 15
min_top_att = 85
min_days_att = 53
discard_overlapping = TRUE
# Check format of input data
check_input(gps_data)
# Record the start time
start_time <- Sys.time()
# Create a vector of bursts to loop through
bursts <- unique(gps_data$burst)
burst_id <- bursts[i]
i=1
burst_id <- bursts[i]
dat <- gps_data %>%
filter(burst==burst_id)
# Order by date and assign location id
dat <- dat %>%
arrange(date) %>%
mutate(loc_id = 1:nrow(.)) %>%
select(loc_id, everything())
# Handle dates
dat <- date_handler(dat, sea_start, sea_end)
dmat <- dist_mat(dat)
cands <- get_candidates(dm = dmat, buffer = buffer, min_pts = min_pts)
# Remove distance matrix to free up RAM
rm(dmat)
gc()
# Summarize candidates
cands_count <- candidate_summary(cands)
head(cand)
head(cands)
cands_count
# Join group ID back to the original data
dat <- left_join(dat, cands, by = "loc_id")
# Save computation time: discard group IDs that appear on days < min_consec
keepers <- dat %>%
group_by(group_id, reldate) %>%
tally() %>%
filter(n >= min_consec) %>%
pull(group_id) %>%
unique()
# Subset data for group_ids of interest
sub <- dat %>%
filter(group_id %in% keepers)
head(sub)
# Sequence of all the possible days in the season
all_days <- 0:max(sub$reldate)
# Initialize output
out <- data.frame(group_id = sort(unique(sub$group_id)))
# Number of fixes per day
daily_fixes <- sub %>%
group_by(reldate) %>%
summarize(n_fixes = n()) %>%
select(reldate, n_fixes) %>%
arrange(reldate)
# Day of first and last visit
first_vis <- sub %>%
group_by(group_id) %>%
summarize(first_date=as_date(min(date)), first_reldate=min(reldate))
last_vis <- sub %>%
group_by(group_id) %>%
summarize(last_date=as_date(max(date)), last_reldate=max(reldate))
# Join to output
out <- out %>%
left_join(first_vis, by = "group_id") %>%
left_join(last_vis, by = "group_id")
# Total number of visits
tot_visits <- sub %>%
group_by(group_id) %>%
summarize(tot_vis = n())
# Number of days visited
days_visited <- sub %>%
group_by(group_id) %>%
summarize(days_vis = n_distinct(reldate))
#Join to output
out <- out %>%
left_join(tot_visits, by = "group_id") %>%
left_join(days_visited, by = "group_id")
# Percent days visited between first and last
out <- out %>%
mutate(perc_days_vis =
round(days_vis*100/(last_reldate - first_reldate + 1), 2))
# Count daily visits
daily_visits <- sub %>%
group_by(group_id, reldate) %>%
summarize(n_visits = n())
# Create data.frame of the range of days a group_id appears
group_id_range <- data.frame(group_id = rep(out$group_id, each=length(all_days)),
reldate = rep(0:max(sub$reldate), length(out$group_id))
) %>%
left_join(first_vis, by = "group_id") %>%
left_join(last_vis, by = "group_id") %>%
filter(between(reldate, first_reldate, last_reldate)) %>%
select(group_id, reldate)
# Combine with daily_visits
daily_visits <- group_id_range %>%
left_join(daily_visits, by = c("group_id", "reldate")) %>%
mutate(n_visits = case_when(
is.na(n_visits) ~ 0L,
TRUE ~ n_visits
)) %>%
left_join(daily_fixes, by = "reldate") %>%
mutate(n_fixes = case_when(
is.na(n_fixes) ~ 0L,
TRUE ~ n_fixes
))
# Find day with most visits
top_day_visits <- daily_visits %>%
group_by(group_id) %>%
filter(n_visits == max(n_visits)) %>%
mutate(percent_vis = round(n_visits*100/n_fixes, 2)) %>%
summarize(perc_top_vis = max(percent_vis))
# Join with output
out <- out %>%
left_join(top_day_visits, by = "group_id")
# For calculating consecutive visits, drop any days without the
# minimum number of required fixes where a visit is not recorded
filtered_dv <- daily_visits %>%
filter(n_visits > 0 | n_fixes >= min_d_fix) %>%
mutate(visited = n_visits > 0)
# For each group_id, calculate the maximum number of consecutive days with a visit
# Split into list by group_id
filtered_list <- split(filtered_dv, filtered_dv$group_id)
filtered_dv
# lapply() custom function 'visit_rle()'
filtered_rle <- lapply(filtered_list, visit_rle)
filtered_rle
filtered_list
min_consec=2
min_top_att=1
min_days_att=1
# Check format of input data
check_input(gps_data)
# Create a vector of bursts to loop through
bursts <- unique(gps_data$burst)
burst_id <- bursts[i]
cat(paste0("Burst ", i, " of ", length(bursts), "\n"))
cat(paste0("Processing ", burst_id, "\n"))
# Order by date and assign location id
dat <- dat %>%
arrange(date) %>%
mutate(loc_id = 1:nrow(.)) %>%
select(loc_id, everything())
# Handle dates
dat <- date_handler(dat, sea_start, sea_end)
dmat <- dist_mat(dat)
cands <- get_candidates(dm = dmat, buffer = buffer, min_pts = min_pts)
# Remove distance matrix to free up RAM
rm(dmat)
gc()
# Summarize candidates
cands_count <- candidate_summary(cands)
cands_count
data(woodstorks)
gps_data <- woodstorks
sea_start = "11-01"
sea_end = "08-31"
nest_cycle = 110
buffer = 40
min_pts = 2
min_d_fix = 5
min_consec = 2
min_top_att = 1
min_days_att = 1
discard_overlapping = TRUE
# Check format of input data
check_input(gps_data)
# Create a vector of bursts to loop through
bursts <- unique(gps_data$burst)
i=1
burst_id <- bursts[i]
dat <- gps_data %>%
filter(burst==burst_id)
# Order by date and assign location id
dat <- dat %>%
arrange(date) %>%
mutate(loc_id = 1:nrow(.)) %>%
select(loc_id, everything())
# Handle dates
dat <- date_handler(dat, sea_start, sea_end)
dmat <- dist_mat(dat)
cands <- get_candidates(dm = dmat, buffer = buffer, min_pts = min_pts)
# Remove distance matrix to free up RAM
rm(dmat)
gc()
# Summarize candidates
cands_count <- candidate_summary(cands)
cands_count
# Join group ID back to the original data
dat <- left_join(dat, cands, by = "loc_id")
# Save computation time: discard group IDs that appear on days < min_consec
keepers <- dat %>%
group_by(group_id, reldate) %>%
tally() %>%
filter(n >= min_consec) %>%
pull(group_id) %>%
unique()
# Subset data for group_ids of interest
sub <- dat %>%
filter(group_id %in% keepers)
# Sequence of all the possible days in the season
all_days <- 0:max(sub$reldate)
# Initialize output
out <- data.frame(group_id = sort(unique(sub$group_id)))
# Number of fixes per day
daily_fixes <- sub %>%
group_by(reldate) %>%
summarize(n_fixes = n()) %>%
select(reldate, n_fixes) %>%
arrange(reldate)
# Day of first and last visit
first_vis <- sub %>%
group_by(group_id) %>%
summarize(first_date=as_date(min(date)), first_reldate=min(reldate))
last_vis <- sub %>%
group_by(group_id) %>%
summarize(last_date=as_date(max(date)), last_reldate=max(reldate))
# Join to output
out <- out %>%
left_join(first_vis, by = "group_id") %>%
left_join(last_vis, by = "group_id")
# Total number of visits
tot_visits <- sub %>%
group_by(group_id) %>%
summarize(tot_vis = n())
# Number of days visited
days_visited <- sub %>%
group_by(group_id) %>%
summarize(days_vis = n_distinct(reldate))
#Join to output
out <- out %>%
left_join(tot_visits, by = "group_id") %>%
left_join(days_visited, by = "group_id")
# Percent days visited between first and last
out <- out %>%
mutate(perc_days_vis =
round(days_vis*100/(last_reldate - first_reldate + 1), 2))
# Count daily visits
daily_visits <- sub %>%
group_by(group_id, reldate) %>%
summarize(n_visits = n())
# Create data.frame of the range of days a group_id appears
group_id_range <- data.frame(group_id = rep(out$group_id, each=length(all_days)),
reldate = rep(0:max(sub$reldate), length(out$group_id))
) %>%
left_join(first_vis, by = "group_id") %>%
left_join(last_vis, by = "group_id") %>%
filter(between(reldate, first_reldate, last_reldate)) %>%
select(group_id, reldate)
# Combine with daily_visits
daily_visits <- group_id_range %>%
left_join(daily_visits, by = c("group_id", "reldate")) %>%
mutate(n_visits = case_when(
is.na(n_visits) ~ 0L,
TRUE ~ n_visits
)) %>%
left_join(daily_fixes, by = "reldate") %>%
mutate(n_fixes = case_when(
is.na(n_fixes) ~ 0L,
TRUE ~ n_fixes
))
# Find day with most visits
top_day_visits <- daily_visits %>%
group_by(group_id) %>%
filter(n_visits == max(n_visits)) %>%
mutate(percent_vis = round(n_visits*100/n_fixes, 2)) %>%
summarize(perc_top_vis = max(percent_vis))
# Join with output
out <- out %>%
left_join(top_day_visits, by = "group_id")
# For calculating consecutive visits, drop any days without the
# minimum number of required fixes where a visit is not recorded
filtered_dv <- daily_visits %>%
filter(n_visits > 0 | n_fixes >= min_d_fix) %>%
mutate(visited = n_visits > 0)
filtered_dv
library(nestR)
data(woodstorks)
wost_output_1 <- find_nests(gps_data = woodstorks,
sea_start = "11-01",
sea_end = "08-31",
nest_cycle = 110,
buffer = 40,
min_pts = 2,
min_d_fix = 5,
min_consec = 2,
min_top_att = 1,
min_days_att = 1,
discard_overlapping = FALSE)
wost_output_1
wost_output_2 <- find_nests(gps_data = woodstorks,
sea_start = "11-01",
sea_end = "08-31",
nest_cycle = 110,
buffer = 40,
min_pts = 2,
min_d_fix = 5,
min_consec = 15,
min_top_att = 85,
min_days_att = 53,
discard_overlapping = TRUE)
wost_output_2
wost_output_3 <- find_nests(gps_data = woodstorks,
sea_start = "11-01",
sea_end = "08-31",
nest_cycle = 110,
buffer = 40,
min_pts = 2,
min_d_fix = 5,
min_consec = 1,
min_top_att = 94,
min_days_att = 53,
discard_overlapping = TRUE)
wost_output_3
head(wost_output_1)
wost_output_2
wost_output_3
library(nestR)
data("woodstorks")
wost_output_1 <- find_nests(gps_data = woodstorks,
sea_start = "11-01",
sea_end = "08-31",
nest_cycle = 110,
buffer = 40,
min_pts = 2,
min_d_fix = 5,
min_consec = 2,
min_top_att = 1,
min_days_att = 1,
discard_overlapping = FALSE)
head(wost_output_1)
# Check format of input data
check_input(gps_data)
gps_data <- woodstorks
# Check format of input data
check_input(gps_data)
# Create a vector of bursts to loop through
bursts <- unique(gps_data$burst)
i=1
burst_id <- bursts[i]
dat <- gps_data %>%
filter(burst==burst_id)
sea_start <- lubridate::ymd(paste0("1990-", sea_start))
sea_start = "11-01"
sea_end = "08-31"
nest_cycle = 110
buffer = 40
min_pts = 2
min_d_fix = 5
min_consec = 2
min_top_att = 1
min_days_att = 1
discard_overlapping = TRUE
sea_start <- lubridate::ymd(paste0("1990-", sea_start))
sea_start
sea_end <- lubridate::ymd(paste0("1990-", sea_end))
sea_end
(sea_start > sea_end)
# Then the year will change between start and end
s_year <- min(lubridate::year(dat$date))
e_year <- s_year + 1
# Set dummy dates
start_dummy <- end_dummy <- lubridate::ymd("1990-01-01")
#Update the years of the dummy dates
lubridate::year(start_dummy) <- s_year
lubridate::year(end_dummy) <- e_year
# Overwrite month
month(start_dummy) <- lubridate::month(sea_start)
# Overwrite day
day(start_dummy) <- lubridate::day(sea_start)
# Overwrite month
month(end_dummy) <- lubridate::month(sea_end)
# Overwrite day
day(end_dummy) <- lubridate::day(sea_end)
(sum(dplyr::between(lubridate::as_date(dat$date), start_dummy, end_dummy))==0)
# Assign relative date
dat$reldate <- floor(as.numeric(difftime(dat$date, start_dummy,
units="days")))
dat
#Remove any data not within the breeding limits
dat <- dat %>%
filter(date >= start_dummy & date <= end_dummy)
# Order by date and assign location id
dat <- dat %>%
arrange(date) %>%
mutate(loc_id = 1:nrow(.)) %>%
select(loc_id, everything())
# Handle dates
dat <- date_handler(dat, sea_start, sea_end)
sea_start
sea_start = "11-01"
sea_end = "08-31"
# Handle dates
dat <- date_handler(dat, sea_start, sea_end)
dmat <- dist_mat(dat)
cands <- get_candidates(dm = dmat, buffer = buffer, min_pts = min_pts)
# Remove distance matrix to free up RAM
rm(dmat)
gc()
# Summarize candidates
cands_count <- candidate_summary(cands)
# Join group ID back to the original data
dat <- left_join(dat, cands, by = "loc_id")
# Save computation time: discard group IDs that appear on < 2 days
keepers <- dat %>%
group_by(group_id, reldate) %>%
tally() %>%
filter(n >= 2) %>%
pull(group_id) %>%
unique()
# Subset data for group_ids of interest
sub <- dat %>%
filter(group_id %in% keepers)
# Sequence of all the possible days in the season
all_days <- 0:max(sub$reldate)
all_days
# Initialize output
out <- data.frame(group_id = sort(unique(sub$group_id)))
out
# Number of fixes per day
daily_fixes <- sub %>%
group_by(reldate) %>%
summarize(n_fixes = n()) %>%
select(reldate, n_fixes) %>%
arrange(reldate)
daily_fixes
# Day of first and last visit
first_vis <- sub %>%
group_by(group_id) %>%
summarize(first_date=as_date(min(date)), first_reldate=min(reldate))
last_vis <- sub %>%
group_by(group_id) %>%
summarize(last_date=as_date(max(date)), last_reldate=max(reldate))
# Join to output
out <- out %>%
left_join(first_vis, by = "group_id") %>%
left_join(last_vis, by = "group_id")
out
# Total number of visits
tot_visits <- sub %>%
group_by(group_id) %>%
summarize(tot_vis = n())
# Number of days visited
days_visited <- sub %>%
group_by(group_id) %>%
summarize(days_vis = n_distinct(reldate))
#Join to output
out <- out %>%
left_join(tot_visits, by = "group_id") %>%
left_join(days_visited, by = "group_id")
# Percent days visited between first and last
out <- out %>%
mutate(perc_days_vis =
round(days_vis*100/(last_reldate - first_reldate + 1), 2))
# Count daily visits
daily_visits <- sub %>%
group_by(group_id, reldate) %>%
summarize(n_visits = n())
# Create data.frame of the range of days a group_id appears
group_id_range <- data.frame(group_id = rep(out$group_id, each=length(all_days)),
reldate = rep(0:max(sub$reldate), length(out$group_id))
) %>%
left_join(first_vis, by = "group_id") %>%
left_join(last_vis, by = "group_id") %>%
filter(between(reldate, first_reldate, last_reldate)) %>%
select(group_id, reldate)
# Combine with daily_visits
daily_visits <- group_id_range %>%
left_join(daily_visits, by = c("group_id", "reldate")) %>%
mutate(n_visits = case_when(
is.na(n_visits) ~ 0L,
TRUE ~ n_visits
)) %>%
left_join(daily_fixes, by = "reldate") %>%
mutate(n_fixes = case_when(
is.na(n_fixes) ~ 0L,
TRUE ~ n_fixes
))
# Find day with most visits
top_day_visits <- daily_visits %>%
group_by(group_id) %>%
filter(n_visits == max(n_visits)) %>%
mutate(percent_vis = round(n_visits*100/n_fixes, 2)) %>%
summarize(perc_top_vis = max(percent_vis))
# Join with output
out <- out %>%
left_join(top_day_visits, by = "group_id")
# For calculating consecutive visits, drop any days without the
# minimum number of required fixes where a visit is not recorded
filtered_dv <- daily_visits %>%
filter(n_visits > 0 | n_fixes >= min_d_fix) %>%
mutate(visited = n_visits > 0)
# For each group_id, calculate the maximum number of consecutive days with a visit
# Split into list by group_id
filtered_list <- split(filtered_dv, filtered_dv$group_id)
# lapply() custom function 'visit_rle()'
filtered_rle <- lapply(filtered_list, visit_rle)
# lapply() custom function 'rle_to_consec()'
max_days_list <- lapply(filtered_rle, rle_to_consec)
# Combine results in data.frame
consec_days <- data.frame(group_id = as.integer(names(max_days_list)),
consec_days = unlist(max_days_list))
# Join with output
out <- out %>%
left_join(consec_days, by = "group_id")
out
filtered_list
wost_output_2
out
wost_output_2
