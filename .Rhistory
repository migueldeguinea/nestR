nests[[i]] <- nests[[i]] %>%
select(-dist_from_known)
# Subset the rest
rest <- sub %>%
filter(loc_id != nests[[i]]$loc_id)
# If the true nest was found, select a non-nest too
if (nrow(nests[[i]]) > 0) {
# If pick_overlapping == TRUE, pick non-nest among those that
# temporally overlap with the true one
if (pick_overlapping == TRUE) {
# Get start and end of true attempt
true_start <- true_nest %>%
pull(attempt_start)
true_end <- true_nest %>%
pull(attempt_end)
# The non-nest is the top visited among those that temporally
# overlap with the nest
non_nests[[i]] <- rest %>%
filter(between(attempt_start, true_start, true_end) |
between(attempt_end, true_start, true_end)) %>%
slice(1)
# Get rid of dist_from_known column
non_nests[[i]] <- non_nests[[i]] %>%
select(-dist_from_known)
} else { # Otherwise, if pick_overlapping == FALSE, the non-nest
# is simply the top visited among the other points
# The non-nest is the top visited among the rest
non_nests[[i]] <- rest %>%
filter(tot_vis == max(rest$tot_vis)) %>%
slice(1)
# Get rid of dist_from_known column
non_nests[[i]] <- non_nests[[i]] %>%
select(-dist_from_known)
}
}
}
pick_overlapping == TRUE
pick_overlapping = TRUE
# Loop through each burst
for (i in unique(candidate_nests$burst)) {
# Subset burst and order by total visits
sub <- candidate_nests %>%
filter(burst == i) %>%
arrange(desc(tot_vis))
# Make into matrix for distance computation
cands_matrix <- sub %>%
select(long, lat) %>%
as.matrix(ncol = 2)
# Select known nest location
known <- known_coords %>%
filter(burst == i) %>%
select(long, lat)
# Compute distance of each candidate from real nest
sub$dist_from_known <- distGeo(cands_matrix, known)
# Subset candidates within buffer distance of known nest location
true_nest <- sub %>%
filter(dist_from_known <= buffer) %>%
slice(1)
# The real nest is the top (most visited) among those
nests[[i]] <- true_nest
# Get rid of dist_from_known column
nests[[i]] <- nests[[i]] %>%
select(-dist_from_known)
# Subset the rest
rest <- sub %>%
filter(loc_id != nests[[i]]$loc_id)
# If the true nest was found, select a non-nest too
if (nrow(nests[[i]]) > 0) {
# If pick_overlapping == TRUE, pick non-nest among those that
# temporally overlap with the true one
if (pick_overlapping == TRUE) {
# Get start and end of true attempt
true_start <- true_nest %>%
pull(attempt_start)
true_end <- true_nest %>%
pull(attempt_end)
# The non-nest is the top visited among those that temporally
# overlap with the nest
non_nests[[i]] <- rest %>%
filter(between(attempt_start, true_start, true_end) |
between(attempt_end, true_start, true_end)) %>%
slice(1)
# Get rid of dist_from_known column
non_nests[[i]] <- non_nests[[i]] %>%
select(-dist_from_known)
} else { # Otherwise, if pick_overlapping == FALSE, the non-nest
# is simply the top visited among the other points
# The non-nest is the top visited among the rest
non_nests[[i]] <- rest %>%
filter(tot_vis == max(rest$tot_vis)) %>%
slice(1)
# Get rid of dist_from_known column
non_nests[[i]] <- non_nests[[i]] %>%
select(-dist_from_known)
}
}
}
# Subset burst and order by total visits
sub <- candidate_nests %>%
filter(burst == i) %>%
arrange(desc(tot_vis))
sub
# Make into matrix for distance computation
cands_matrix <- sub %>%
select(long, lat) %>%
as.matrix(ncol = 2)
cands_matrix
# Select known nest location
known <- known_coords %>%
filter(burst == i) %>%
select(long, lat)
known
# Compute distance of each candidate from real nest
sub$dist_from_known <- distGeo(cands_matrix, known)
sub
# Subset candidates within buffer distance of known nest location
true_nest <- sub %>%
filter(dist_from_known <= buffer) %>%
slice(1)
# The real nest is the top (most visited) among those
nests[[i]] <- true_nest
# Get rid of dist_from_known column
nests[[i]] <- nests[[i]] %>%
select(-dist_from_known)
# Subset the rest
rest <- sub %>%
filter(loc_id != nests[[i]]$loc_id)
rest
nests[[i]]
true_nest
sub
library(nestR)
(!missing(known_coords) && !missing(buffer))
# Case 1: known_coords and buffer are provided
if (!missing(known_coords) && !missing(buffer)) {
# Keep only bursts for which we have a known nest
candidate_nests <- candidate_nests %>%
filter(burst %in% known_coords$burst)
# Create empty lists to store results
nests <- list()
non_nests <- list()
# Loop through each burst
for (i in unique(candidate_nests$burst)) {
# Subset burst and order by total visits
sub <- candidate_nests %>%
filter(burst == i) %>%
arrange(desc(tot_vis))
# Make into matrix for distance computation
cands_matrix <- sub %>%
select(long, lat) %>%
as.matrix(ncol = 2)
# Select known nest location
known <- known_coords %>%
filter(burst == i) %>%
select(long, lat)
# Compute distance of each candidate from real nest
sub$dist_from_known <- distGeo(cands_matrix, known)
# Subset candidates within buffer distance of known nest location
true_nest <- sub %>%
filter(dist_from_known <= buffer) %>%
slice(1)
# The real nest is the top (most visited) among those
nests[[i]] <- true_nest
# Get rid of dist_from_known column
nests[[i]] <- nests[[i]] %>%
select(-dist_from_known)
# If the true nest was found, select a non-nest too
if (nrow(nests[[i]]) > 0) {
# Subset the rest
rest <- sub %>%
filter(loc_id != nests[[i]]$loc_id)
# If pick_overlapping == TRUE, pick non-nest among those that
# temporally overlap with the true one
if (pick_overlapping == TRUE) {
# Get start and end of true attempt
true_start <- true_nest %>%
pull(attempt_start)
true_end <- true_nest %>%
pull(attempt_end)
# The non-nest is the top visited among those that temporally
# overlap with the nest
non_nests[[i]] <- rest %>%
filter(between(attempt_start, true_start, true_end) |
between(attempt_end, true_start, true_end)) %>%
slice(1)
# Get rid of dist_from_known column
non_nests[[i]] <- non_nests[[i]] %>%
select(-dist_from_known)
} else { # Otherwise, if pick_overlapping == FALSE, the non-nest
# is simply the top visited among the other points
# The non-nest is the top visited among the rest
non_nests[[i]] <- rest %>%
filter(tot_vis == max(rest$tot_vis)) %>%
slice(1)
# Get rid of dist_from_known column
non_nests[[i]] <- non_nests[[i]] %>%
select(-dist_from_known)
}
}
}
} else if (!missing(known_ids)) {
# Case 2: known_ids are provided
# Keep only bursts for which we have a known nest
candidate_nests <- candidate_nests %>%
filter(burst %in% known_ids$burst)
# Create empty lists to store results
nests <- list()
non_nests <- list()
for (i in unique(candidate_nests$burst)) {
# Subset burst and order by total visits
sub <- candidate_nests %>%
filter(burst == i) %>%
arrange(desc(tot_vis))
# Select known nest location
known <- known_ids %>%
filter(burst == i) %>%
pull(loc_id)
# Select real nest based on location ID
true_nest <- sub %>%
filter(loc_id == known)
# Store in list
nests[[i]] <- true_nest
# Subset the rest
rest <- sub %>%
filter(loc_id != known)
# If the true nest was found, select a non-nest too
if (nrow(nests[[i]]) > 0) {
# If pick_overlapping == TRUE, pick non-nest among those that
# temporally overlap with the true one
if (pick_overlapping == TRUE) {
# Get start and end of true attempt
true_start <- true_nest %>%
pull(attempt_start)
true_end <- true_nest %>%
pull(attempt_end)
# The non-nest is the top visited among those that temporally
# overlap with the nest
non_nests[[i]] <- rest %>%
filter(between(attempt_start, true_start, true_end) |
between(attempt_end, true_start, true_end)) %>%
slice(1)
} else { # Otherwise, if pick_overlapping == FALSE, the non-nest
# is simply the top visited among the other points
# The non-nest is the top visited among the rest
non_nests[[i]] <- rest %>%
filter(tot_vis == max(rest$tot_vis)) %>%
slice(1)
}
}
}
}
nests_df <- do.call("rbind", nests)
non_nests_df <- do.call("rbind", non_nests)
nests_df
non_nests_df
# Loop through each burst
for (i in unique(candidate_nests$burst)) {
# Subset burst and order by total visits
sub <- candidate_nests %>%
filter(burst == i) %>%
arrange(desc(tot_vis))
# Make into matrix for distance computation
cands_matrix <- sub %>%
select(long, lat) %>%
as.matrix(ncol = 2)
# Select known nest location
known <- known_coords %>%
filter(burst == i) %>%
select(long, lat)
# Compute distance of each candidate from real nest
sub$dist_from_known <- distGeo(cands_matrix, known)
# Subset candidates within buffer distance of known nest location
true_nest <- sub %>%
filter(dist_from_known <= buffer) %>%
slice(1)
# The real nest is the top (most visited) among those
nests[[i]] <- true_nest
# Get rid of dist_from_known column
nests[[i]] <- nests[[i]] %>%
select(-dist_from_known)
# If the true nest was found, select a non-nest too
if (nrow(nests[[i]]) > 0) {
# Subset the rest
rest <- sub %>%
filter(loc_id != nests[[i]]$loc_id)
# If pick_overlapping == TRUE, pick non-nest among those that
# temporally overlap with the true one
if (pick_overlapping == TRUE) {
# Get start and end of true attempt
true_start <- true_nest %>%
pull(attempt_start)
true_end <- true_nest %>%
pull(attempt_end)
# The non-nest is the top visited among those that temporally
# overlap with the nest
non_nests[[i]] <- rest %>%
filter(between(attempt_start, true_start, true_end) |
between(attempt_end, true_start, true_end)) %>%
slice(1)
# Get rid of dist_from_known column
non_nests[[i]] <- non_nests[[i]] %>%
select(-dist_from_known)
} else { # Otherwise, if pick_overlapping == FALSE, the non-nest
# is simply the top visited among the other points
# The non-nest is the top visited among the rest
non_nests[[i]] <- rest %>%
filter(tot_vis == max(rest$tot_vis)) %>%
slice(1)
# Get rid of dist_from_known column
non_nests[[i]] <- non_nests[[i]] %>%
select(-dist_from_known)
}
}
}
non_nests
i
i="721300-2008"
# Subset burst and order by total visits
sub <- candidate_nests %>%
filter(burst == i) %>%
arrange(desc(tot_vis))
sub
# Make into matrix for distance computation
cands_matrix <- sub %>%
select(long, lat) %>%
as.matrix(ncol = 2)
cands_matrix
# Select known nest location
known <- known_coords %>%
filter(burst == i) %>%
select(long, lat)
# Compute distance of each candidate from real nest
sub$dist_from_known <- distGeo(cands_matrix, known)
# Subset candidates within buffer distance of known nest location
true_nest <- sub %>%
filter(dist_from_known <= buffer) %>%
slice(1)
# The real nest is the top (most visited) among those
nests[[i]] <- true_nest
# Get rid of dist_from_known column
nests[[i]] <- nests[[i]] %>%
select(-dist_from_known)
nests[[i]]
# Subset the rest
rest <- sub %>%
filter(loc_id != nests[[i]]$loc_id)
rest
(pick_overlapping == TRUE)
# Get start and end of true attempt
true_start <- true_nest %>%
pull(attempt_start)
true_start
true_end <- true_nest %>%
pull(attempt_end)
# The non-nest is the top visited among those that temporally
# overlap with the nest
non_nests[[i]] <- rest %>%
filter(between(attempt_start, true_start, true_end) |
between(attempt_end, true_start, true_end)) %>%
slice(1)
non_nests[[i]]
sub
true_start
true_end
rest
# Case 1: known_coords and buffer are provided
if (!missing(known_coords) && !missing(buffer)) {
# Keep only bursts for which we have a known nest
candidate_nests <- candidate_nests %>%
filter(burst %in% known_coords$burst)
# Create empty lists to store results
nests <- list()
non_nests <- list()
# Loop through each burst
for (i in unique(candidate_nests$burst)) {
# Subset burst and order by total visits
sub <- candidate_nests %>%
filter(burst == i) %>%
arrange(desc(tot_vis))
# Make into matrix for distance computation
cands_matrix <- sub %>%
select(long, lat) %>%
as.matrix(ncol = 2)
# Select known nest location
known <- known_coords %>%
filter(burst == i) %>%
select(long, lat)
# Compute distance of each candidate from real nest
sub$dist_from_known <- distGeo(cands_matrix, known)
# Subset candidates within buffer distance of known nest location
true_nest <- sub %>%
filter(dist_from_known <= buffer) %>%
slice(1)
# The real nest is the top (most visited) among those
nests[[i]] <- true_nest
# Get rid of dist_from_known column
nests[[i]] <- nests[[i]] %>%
select(-dist_from_known)
# If the true nest was found, select a non-nest too
if (nrow(nests[[i]]) > 0) {
# Subset the rest
rest <- sub %>%
filter(loc_id != nests[[i]]$loc_id)
# If pick_overlapping == TRUE, pick non-nest among those that
# temporally overlap with the true one
if (pick_overlapping == TRUE) {
# Get start and end of true attempt
true_start <- true_nest %>%
pull(attempt_start)
true_end <- true_nest %>%
pull(attempt_end)
# The non-nest is the top visited among those that temporally
# overlap with the nest
non_nests[[i]] <- rest %>%
filter(between(attempt_start, true_start, true_end) |
between(attempt_end, true_start, true_end)) %>%
slice(1)
# Get rid of dist_from_known column
non_nests[[i]] <- non_nests[[i]] %>%
select(-dist_from_known)
} else { # Otherwise, if pick_overlapping == FALSE, the non-nest
# is simply the top visited among the other points
# The non-nest is the top visited among the rest
non_nests[[i]] <- rest %>%
filter(tot_vis == max(rest$tot_vis)) %>%
slice(1)
# Get rid of dist_from_known column
non_nests[[i]] <- non_nests[[i]] %>%
select(-dist_from_known)
}
}
}
} else if (!missing(known_ids)) {
# Case 2: known_ids are provided
# Keep only bursts for which we have a known nest
candidate_nests <- candidate_nests %>%
filter(burst %in% known_ids$burst)
# Create empty lists to store results
nests <- list()
non_nests <- list()
for (i in unique(candidate_nests$burst)) {
# Subset burst and order by total visits
sub <- candidate_nests %>%
filter(burst == i) %>%
arrange(desc(tot_vis))
# Select known nest location
known <- known_ids %>%
filter(burst == i) %>%
pull(loc_id)
# Select real nest based on location ID
true_nest <- sub %>%
filter(loc_id == known)
# Store in list
nests[[i]] <- true_nest
# Subset the rest
rest <- sub %>%
filter(loc_id != known)
# If the true nest was found, select a non-nest too
if (nrow(nests[[i]]) > 0) {
# If pick_overlapping == TRUE, pick non-nest among those that
# temporally overlap with the true one
if (pick_overlapping == TRUE) {
# Get start and end of true attempt
true_start <- true_nest %>%
pull(attempt_start)
true_end <- true_nest %>%
pull(attempt_end)
# The non-nest is the top visited among those that temporally
# overlap with the nest
non_nests[[i]] <- rest %>%
filter(between(attempt_start, true_start, true_end) |
between(attempt_end, true_start, true_end)) %>%
slice(1)
} else { # Otherwise, if pick_overlapping == FALSE, the non-nest
# is simply the top visited among the other points
# The non-nest is the top visited among the rest
non_nests[[i]] <- rest %>%
filter(tot_vis == max(rest$tot_vis)) %>%
slice(1)
}
}
}
}
nests_df
non_nests_df
non_nests
i="414590-2009"
# Subset burst and order by total visits
sub <- candidate_nests %>%
filter(burst == i) %>%
arrange(desc(tot_vis))
sub
i="721290-2010"
# Subset burst and order by total visits
sub <- candidate_nests %>%
filter(burst == i) %>%
arrange(desc(tot_vis))
sub
library(nestR)
library(nestR)
library(nestR)
library(nestR)
library(nestR)
vignette("nestR")
vignette(nestR)
?vignette
vignette(package = "nestR")
browseVignettes(package = "nestR")
vignette(package = nestR)
vignette(package = "nestR")
?install_github
?devtools::install_github
